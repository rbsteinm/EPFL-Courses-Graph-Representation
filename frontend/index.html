<html>
<!--
TODO fix bug unzoom edges not rendered
    the bug occurs when selection event, then zoom, then selection event again
    the solution is either to still update everything that's not visible in the background
    or to re-update everything at each click (which is the same as not disambiguiating click and zoom?) <== that's the solution implemented for the moment
TODO connected courses on infopanel
TODO re-implement search function
TODO rethink the colors and design
TODO nodes "clustering" (supernodes)
TODO handle screen rotate (recompute width and height?)


DONE when a node is selected and there's a redraw, only redraw the selected edges
DONE disambiguiate click and zoom to not redraw when click
DONE infopanel
DONE hide arrowheads when unzoom threshold is reached for cleaner display
DONE constrain zoom (for ex. stop when all nodes are visible)
DONE adaptive labels font size
DONE only display titles of visible nodes
DONE display titles above nodes
DONE dashed lines (import type of edges)
DONE take radius into account in node_is_visible function
DONE zindex of node should be higher that those of edges to avoid misclicks on edges
DONE batch drawing edges: drawing only edge outgoing from visible nodes is wrong. Draw all visible edges
DONE batch drawing edges
    DONE interrupt drawing between the batches if a move has been made
    DONE fade in the edges when you draw them
-->
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPFL courses</title>
</head>

<body>
<!--<form role="search" class="navbar-form" id="search">
    <div class="form-group">
        <input type="text" placeholder="Search for courses" class="form-control" name="search">
    </div>
    <button class="btn btn-default" type="submit">Search</button>
</form>-->


<div id="graph" class = "svg-container"></div>
<div id='infopanel'></div>

<!--<table id="results" class="table table-striped table-hover">
    <thead>
    <tr>
        <th>Course</th>
        <th>Code</th>
    </tr>
    </thead>
    <tbody>
    </tbody>
</table>-->



<style type="text/css">
    body{
        margin: 0px;
        font-family: sans-serif;
    }
    .link {
        stroke: rgba(125, 125, 125, .8);
        stroke-width: 1px;
        position: absolute;
        pointer-events: none;
    }

    .indicative_link{
        stroke-dasharray: 5;
    }

    .svg-container {
        display: inline-block;
        position: absolute;
        width: 100%;
        height: 100% ;
        vertical-align: top;
        overflow: hidden;
    }
    .svg-content {
        display: inline-block;
        position: absolute;
        width:100%;
        height: 100% ;  
        top: 0;
        left: 0;
    }

    .node{
        fill: rgba(125, 125, 125, 1);
        r: 13;
        position:absolute;
    }

    .node_title{
        font-family: sans-serif;
        font-size: 12px;
        fill: black;
        pointer-events: none;
    }

    .selected_node{
        fill: black;
        r: 4;
    }

    .unselected_node{

    }

    #infopanel{
        background-color: white;
        position: absolute;
        width: 80%;
        /*height: 20%;*/
        bottom: 2%;
        left: 10%;
        margin-bottom: 10px;

        border: 2px black solid;
        border-radius: 10px;
        padding: 10px;
        opacity: 0;
        pointer-events: none;
    }
    </style>

<script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="http://d3js.org/d3.v4.min.js" type="text/javascript"></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>
<script src="/libraries/gexf-parser.min.js"></script>
<!--<script src="https://1.jsconsole.com/js/remote.js?70fb9ec0-cab3-4775-9ab5-9daa813b0e48"></script>-->

<script type="text/javascript">

    const NODE_COLOR = "rgba(125, 125, 125, 1)";
    const EDGE_COLOR = "rgba(125, 125, 125, 0.8)";
    const SELECTED_NODE_COLOR = "rgba(0, 0, 0, 1)";
    const SELECTED_EDGE_COLOR = "rgba(0, 0, 0, 0.8)";
    const BACKGROUND_NODE_COLOR = "rgb(235,235,235)";
    const BACKGROUND_EDGE_COLOR = "rgb(229,229,229)";

    const BATCH_SIZE = 50;
    const SHOW_LABELS_THRESHOLD = 0.5;
    const NODE_SIZE = 13;
    const MAX_NODE_SIZE = 75;
    const FONT_SIZE = 12;
    const ZOOM_CONSTRAIN = [0.05, 2.5];
    const HIDE_ARROWHEADS_THRESHOLD = 0.25;
    //const HIGHLIGHT_COLORS = ['#5C5C5C', '#454545', '#2E2E2E', '#171717', '#000000'];
    const HIGHLIGHT_COLORS = ['rgb(180, 180, 180)', 'rgb(100, 100, 100)', 'rgb(0, 0, 0)'];

    let nodes = {};
    let edges = {};
    let NODE_SELECTION = [];
    let EDGE_SELECTION = [];
    let course_descriptions = {};
    let course_sections = {};
    let adjacency_list = {};
    let drawing_timer;
    let drawing_complete = true;
    let show_labels = true;
    let arrowheads_visible = true;
    let ZOOMED = false;


    // define width/height as the svg container dimensions
    const width = document.getElementsByClassName('svg-container')[0].clientWidth;
    const height = document.getElementsByClassName('svg-container')[0].clientHeight;

    let svg = d3.select("div#graph").append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .classed("svg-content", true);

    let g = svg.append("g");

    svg.append('defs')
    .append('marker')
    .attrs({'id':'arrowhead',
        'viewBox':'-0 -5 10 10',
        'refX':23,
        'refY':0,
        'orient':'auto',
        'markerWidth':0.7 * NODE_SIZE,
        'markerHeight':0.7 * NODE_SIZE,
        'xoverflow':'visible'})
    .append('svg:path')
    .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
    .attr('fill', '#999')
    .style('stroke','none');


    // handle zoom events on the svg
    let zoom_handler = d3.zoom()
        .scaleExtent(ZOOM_CONSTRAIN)
        .on("start", function(){
            return zoomBegin();
        })
        .on("end", function(){
            return zoomEnd(width, height, d3.event.transform);
        })
        .on("zoom", function(){
            return zoomed(width, height, d3.event.transform);
        });

    svg.call(zoom_handler);

    // When the background is clicked, clear the current selection
    d3.select("div#graph").on("click", function(){
        clear_selection(false);
        hide_infopanel();
        show_node_labels(d3.zoomTransform(svg.node()));
        zoomBegin();
        zoomed(width, height, d3.zoomTransform(svg.node()));
        zoomEnd(width, height, d3.zoomTransform(svg.node()));
    });


    // this function imports the data from a .gexf file
    // the advantage of gexf file is that we can use Gephi's algorithm to have a nice pre-defined layout
    // a callback function displays the data once it's loaded
    function import_data(path, display_callback){
        var graph = gexf.fetch(path);

        // import nodes data
        graph.nodes.forEach(function(n){
            nodes['nid_' + n.id] = {
                'x': n.viz.position.x,
                'y': n.viz.position.y,
                'title': n.attributes.subjectname,
                'id': 'nid_' + n.id
            };
        });

        // import edges data
        graph.edges.forEach(function(e){
            edges['eid_' + e.id] = {
                'source': 'nid_' + e.source,
                'target': 'nid_' + e.target,
                'x1': graph.nodes.filter(node => node.id == e.source)[0].viz.position.x,
                'y1': graph.nodes.filter(node => node.id == e.source)[0].viz.position.y,
                'x2': graph.nodes.filter(node => node.id == e.target)[0].viz.position.x,
                'y2': graph.nodes.filter(node => node.id == e.target)[0].viz.position.y,
                'id': 'eid_' + e.id,
                'type': e.label
            }
        });

        // fill the adjacency list
        Object.values(edges).forEach(function(e){
            if(!adjacency_list[e.source]) adjacency_list[e.source] = [];
            adjacency_list[(e.source)].push(e.id);
        });

        // display the data when loading is done
        display_callback();
    }

    // this function creates a circle for each course and an edge for each relationship
    // it is called as a callback of the import_data method
    function display_graph(){
        // create an SVG line for each link in the JSON data
        g.selectAll(".link")
            .data(Object.values(edges)).enter()
            .append("line")
            .attr("x1", function(d) {return d.x1;})
            .attr("y1", function(d) {return d.y1;})
            .attr("x2", function(d) {return d.x2;})
            .attr("y2", function(d) {return d.y2;})
            .attr("id", function(d) {return d.id;})
            .attr("class", function(d) {
                return (d.type == 'baseline') ? 'link': 'link indicative_link';
            })
            .attr('marker-end','url(#arrowhead)');

        // draw the nodes
        g.selectAll(".node")
            .data(Object.values(nodes)).enter()
            .append("circle")
            .attr("cx", function(d) {return d.x;})
            .attr("cy", function(d) {return d.y;})
            .attr("class", "node unselected_node")
            .attr("id", d => d.id)
            .on("click", function(d) {
                on_click_node(d);
            });

        // add text above nodes
        g.selectAll("text")
            .data(Object.values(nodes), function(d){return d.id;})
            .enter()
            .append('text')
            .attr('x', function(d){return d.x;})
            .attr('y', function(d){return d.y-10;})
            .attr('id', function(d){return 'title_' + d.id;})
            .attr('class', 'node_title')
            .text(function(d){ return d.title});
    }

    // this function is called when a node is clicked
    function on_click_node(node){
        // highlight the node and its neighbors
        highlight_selection(node);
        // fill the information panel with the node's information
        fill_infopanel(node_to_string(node.id));
        show_infopanel();
        // update visible node labels to show only those of selected courses
        hide_node_labels();
        show_node_labels(d3.zoomTransform(svg.node()));
        // update the graph when a new node is selected
        zoomBegin();
        zoomed(width, height, d3.zoomTransform(svg.node()));
        zoomEnd(width, height, d3.zoomTransform(svg.node()));
        // only the node is clicked, not the background
        event.stopPropagation();
    }

    function import_descriptions(){
        d3.tsv("./data/descriptions.csv")
            .row(function(row){
                course_descriptions['nid_' + row.SubjectID] = row.Summary_EN;
            })
            .get(function(err, rows) {
                if (err) return console.error(err);
            });
    }

    function import_sections(){
        d3.tsv("./data/sections.csv")
            .row(function(row){
                course_sections['nid_' + row.SubjectID] = row.sections.split('|');
            })
            .get(function(err, rows) {
                if (err) return console.error(err);
            });
    }


    // load and display
    import_data('/data/data4.gexf', function(){display_graph();});
    import_descriptions();
    import_sections();



    function get_node_size(scale_factor){
        //return (5/(Math.sqrt(scale_factor))).toFixed(1);
        return Math.min(MAX_NODE_SIZE, (NODE_SIZE/scale_factor));
    }

    function get_line_width(scale_factor){
        return (1.0/((scale_factor))).toFixed(2);
    }

    function get_label_font_size(scale_factor){
        return (FONT_SIZE/scale_factor);
    }

    // returns the coordinates after a transformation (zoom, pan)
    function get_new_coordinates(x, y, transf){
        let x1 = x * transf.k + transf.x,
        y1 = y * transf.k + transf.y;
        return [x1, y1];
    }

    // does this node appear on the screen with the current scale/translate values?
    function node_is_visible(node, width, height, transf){
        let x, y;
        //let radius = parseInt(g.select('#'+node.id).style('r'));
        // hardcoded radius approximation for performance reasons
        let radius = 100;
        [x, y] = get_new_coordinates(node.x, node.y, transf);
        return (x+radius) > 0 && (x-radius) < width && (y+radius) > 0 && (y-radius) < height;
    }

    // does this edge appear on the screen with the current scale/translate values?
    function edge_is_visible(edge, width, height, transf){
        let x1, x2, y1, y2;
        [x1, y1] = get_new_coordinates(edge.x1 ,edge.y1, transf);
        [x2, y2] = get_new_coordinates(edge.x2 ,edge.y2, transf);
        let new_edge = [x1, y1, x2, y2];
        let left_border = [0, 0, 0, height];
        let top_border = [0, 0, width, 0];
        let right_border = [width, 0, width, height];
        let bottom_border = [0, height, width, height];

        // both endpoints are inside the box
        if(x1 > 0 && x1 < width && y1 > 0 && y1 < height && x2 > 0 && x2 < width && y2 > 0 && y2 < height){
            return true;
        }
        // the edge intersects at least one of the borders
        if(line_intersects(new_edge, top_border) || line_intersects(new_edge, left_border) || line_intersects(new_edge, right_border) || line_intersects(new_edge, bottom_border)){
            return true;
        }
        return false;
    }

    // are the two segments intersecting at some point?
    function line_intersects(segment1, segment2) {
        [p0_x, p0_y, p1_x, p1_y] = segment1;
        [p2_x, p2_y, p3_x, p3_y] = segment2;
        var s1_x, s1_y, s2_x, s2_y;
        s1_x = p1_x - p0_x;
        s1_y = p1_y - p0_y;
        s2_x = p3_x - p2_x;
        s2_y = p3_y - p2_y;

        var s, t;
        s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
        t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);

        return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
    }

    // BFS search to highlight the given node and its neighbors
    // is_source: true if the node is the selected node (root node)
    // distance: highlight all nodes that are d hops away from the root, for all d <= distance
    // already_seen: the nodes that were already visited and highlightd by the algorithm (to avoid highlighting a node twice)
    function highlight_selection(node, is_source=true, distance=2, already_seen=[]){
        let node_id = node.id;

        if(is_source){
            clear_selection(true);
            already_seen.push(node_id);
        }
        highlight_node(node, distance);
        NODE_SELECTION.push(node_id);

        // also highlight neighbors (and the edge that links to each neighbor)
        if(distance > 0){
            if(!adjacency_list[node_id]) return;
            let adjacent_edges = adjacency_list[node_id].map(edge_id => get_edge_by_id(edge_id));
            adjacent_edges.forEach(function(edge){
                highlight_edge(edge, distance);
                EDGE_SELECTION.push(edge);
            });
            let unvisited_nodes = adjacent_edges.map(edge => get_neighbor(node_id, edge)).filter(nid => !already_seen.includes(nid));
            unvisited_nodes.forEach(nid => already_seen.push(nid));
            unvisited_nodes.forEach(nid =>  highlight_selection(get_node_by_id(nid), false, distance-1, already_seen));
        }
    }

    // input: an edge and one of its endpoints
    //output: the other edge's endpoint
    function get_neighbor(node_id, edge){
        let neighbor;
        if(node_id == edge.source){
            neighbor = (edge.target);
        }
        else if(node_id == edge.target){
            neighbor = (edge.source);
        }
        return neighbor;
    }

    // highlights the given node with opacity proportional to the root distance
    function highlight_node(node, distance_to_leaf){
        //const opacity = 0.4 + 0.3 * distance_to_leaf;
        //d3.select('circle#'+node.id).style('fill', "rgba(0, 0, 0, " + opacity + ")");
        d3.select('circle#'+node.id).style('fill', HIGHLIGHT_COLORS[distance_to_leaf]);
        d3.select('circle#'+node.id).style('visibility', 'visible');

    }

    // highlights an edge
    function highlight_edge(edge, distance_to_leaf){
        d3.select('#' + edge.id).style('stroke', SELECTED_EDGE_COLOR);
         d3.select('#' + edge.id).style('visibility', 'visible');
    }

    // returns the DOM node object given its node ID
    function get_node_by_id(id){
        return d3.select('#'+id).data()[0];
    }

    //input: edge id
    // output: the edge's data
    function get_edge_by_id(id){
        return d3.select('#'+id).data()[0];
    }

    // clears the highlighting and all node/edge selection
    function clear_selection(new_selection=false){
        NODE_SELECTION = [];
        EDGE_SELECTION = [];
        if(new_selection){
            //d3.selectAll('.node').style('fill', BACKGROUND_NODE_COLOR);
            //d3.selectAll('.link').style('stroke', BACKGROUND_EDGE_COLOR);
            d3.selectAll('.node').style('visibility', 'hidden');
            d3.selectAll('.link').style('visibility', 'hidden');
        }
        else{
            d3.selectAll('.node').style('fill', NODE_COLOR);
            d3.selectAll('.link').style('stroke', EDGE_COLOR);
            d3.selectAll('.node').style('visibility', 'visible');
            d3.selectAll('.link').style('visibility', 'visible');
        }
    }

    // This code is executed everytime the page is zoomed
    // It dinamically resizes the nodes and the edges
    // but only if they are visible to reduce computation time
    function zoomed(width, height, transform){
        // hide all links
        d3.selectAll('.link').style('display', 'none');
        // hide node labels
        hide_node_labels();
        // transform
        g.attr("transform", transform);
        // update node size
        const radius = get_node_size(transform.k);
        d3.selectAll('.node').filter(node => node_is_visible(node, width, height, transform)).style("r", radius);
        console.log('zommed');
        ZOOMED = true;
    }

    // this function is called at the beginning of any zoom or drag event
    // it interrupts any ongoing drawing of edges
    function zoomBegin(){
        // Stop the timer if a zoom/drag occurs
        if(drawing_timer){
            console.log('stopped timer')
            drawing_timer.stop();
        }
    }

    // this function is called at the end of any zoom or drag event
    // it launches the redrawing of visible edges
    // the visible edges are drawn by batches of size BATCH_SIZE
    function zoomEnd(width, height, transform){
        // check if the graph has been moved
        // this allows to distinguish a click and a drag event
        if(ZOOMED){
            update_graph(width, height, transform);
            show_node_labels(transform);
            show_hide_arrowheads(transform);
            ZOOMED = false;
        }
    }

    // this function draws a single batch of edges
    // batch: an array of edge IDs to draw
    // line_width: the stroke width of the edges
    function draw_edge_batch(batch, line_width){
        g.selectAll('.link')
            .data(batch, function(e){return e.id;})
            //.style('stroke-width', 0)
            //.transition().duration(200)
            .style("stroke-width", line_width)
            .style('display', 'block');
    }

    
    // this function updates the graph after any zoom or drag
    // it launches the redrawing of visible edges
    // the visible edges are drawn by batches of size BATCH_SIZE
    function update_graph(width, height, transform){
        drawing_complete = false;

        const line_width = get_line_width(transform.k);
        let batch_number = 0;
        let visible_edges = d3.selectAll('.link').filter(edge => edge_is_visible(edge, width, height, transform)).data();
        // if there is a selection, only draw selected edges
        if(EDGE_SELECTION.length > 0) visible_edges = visible_edges.filter(edge => EDGE_SELECTION.includes(edge));
        // this timer calls its parameter function over and over again until it is stopped
        drawing_timer = d3.timer(function(){
            let batch = visible_edges.splice(0, Math.min(BATCH_SIZE, visible_edges.length));
            draw_edge_batch(batch, line_width);
            batch_number += 1;
            // stop the timer if all edges have been drawn
            if(visible_edges.length == 0){
                console.log('drawing complete');
                drawing_timer.stop();
                drawing_complete = true;
            }
        }, 0);
    }

    // shows the labels of the nodes if the zoom threshold is reached
    // only shows labels of visible nodes
    function show_node_labels(transform){
        // is the zoom threshold reached?
        if(transform.k > SHOW_LABELS_THRESHOLD){
            let font_size = get_label_font_size(transform.k);

            // filter out the nodes that do not appear on the screen
            let visible_nodes = d3.selectAll('.node')
            .filter(node => node_is_visible(node, width, height, transform))
            .data();

            // if there is a selection, only show labels of selected nodes
            if(NODE_SELECTION.length > 0) visible_nodes = visible_nodes.filter(node => NODE_SELECTION.includes(node.id));

            // display the label for each visible node
            d3.selectAll('.node_title')
                .data(visible_nodes, function(d){return d.id;})
                .style('display', 'block')
                .style('font-size', font_size);
        }
    }

    // hides all the node labels
    function hide_node_labels(){
        g.selectAll('.node_title').style('display', 'none');
    }

    // at a certain unzooming threshold, the arrowheads are hidden
    // to avoid the graph to be messy
    function show_hide_arrowheads(transform){
        // to zoomed out, don't display arrowheads
        if(transform.k < HIDE_ARROWHEADS_THRESHOLD && arrowheads_visible){
            g.selectAll('.link').attr('marker-end','none');
            arrowheads_visible = false;
            console.log('hide arrowheads');
        }
        // display arrowheads
        else if(transform.k >= HIDE_ARROWHEADS_THRESHOLD && !arrowheads_visible){
            g.selectAll('.link').attr('marker-end','url(#arrowhead)');
            arrowheads_visible = true;
            console.log('show arrowheads');
        }
    }

    function show_infopanel(){
        d3.select('#infopanel').style('opacity', 0).transition().duration(500).style('opacity', 1).style('pointer-events', 'auto');
    }

    function hide_infopanel(){
        d3.select('#infopanel').transition().duration(500).style('opacity', 0).style('pointer-events', 'none');
    }

    function fill_infopanel(text){
        d3.select('#infopanel').html(text);
    }

    function node_to_string(nid){
        let result = '';
        result += '<div><strong>' + nodes[nid].title + '</strong></div><br/>';
        result += '<div>' + course_descriptions[nid] + '</div><br/>';
        if(course_sections[nid]){
            result += '<div>Sections: ';
            result += course_sections[nid].toString();
            result += '</div>';
        }
        return result;
    }


</script>

<script type="text/javascript">
    const t = $("table#results tbody");
    function clear_search(){
        $(".selected_node").attr("class", "node");
        t.empty();
    }

    function search() {
        var query=$("#search").find("input[name=search]").val();
        clear_search();
        if(query.length != 0){
            $.get("/search?q=" + encodeURIComponent(query),
                    function (data) {
                        if (!data || data.length == 0){
                            console.log("empty search");
                            return false;
                        }
                        // for each node returned by the query
                        data.forEach(function (course) {
                            // append a line in the list of selected courses with the course's title and code
                            $("<tr><td class='course'>" + course.title + "</td><td>" + course.code + "</td><td>" + "</td></tr>").appendTo(t);
                            var node = $('#' + course.id);
                            node.attr("class", "node selected_node");
                        });
                    }, "json");
        }
        return false;
        
    }

    $("#search").submit(search);
    //search();
</script>
</body>
</html>
