<html>
<!--
TODO dashed lines (import type of edges)
TODO don't update edges when a node is clicked
TODO display titles above nodes
TODO nodes "clustering" (supernodes)
TODO infopanel
TODO constrain zoom (for ex. stop when all nodes are visible)
TODO re-implement search function


DONE take radius into account in node_is_visible function
DONE zindex of node should be higher that those of edges to avoid misclicks on edges
DONE batch drawing edges: drawing only edge outgoing from visible nodes is wrong. Draw all visible edges
DONE batch drawing edges
    DONE interrupt drawing between the batches if a move has been made
    DONE fade in the edges when you draw them
-->
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPFL courses</title>
</head>

<body>
<form role="search" class="navbar-form" id="search">
    <div class="form-group">
        <input type="text" placeholder="Search for courses" class="form-control" name="search">
    </div>
    <button class="btn btn-default" type="submit">Search</button>
</form>


<div id="graph" class = "svg-container"></div>

<table id="results" class="table table-striped table-hover">
    <thead>
    <tr>
        <th>Course</th>
        <th>Code</th>
    </tr>
    </thead>
    <tbody>
    </tbody>
</table>



<style type="text/css">
    .link {
        stroke: rgba(125, 125, 125, .8);
        stroke-width: 10px;
        position: absolute;
        pointer-events: none;
    }

    .REQUIRE_IND{
        stroke-dasharray: 5;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        height: 85% ;
        vertical-align: top;
        overflow: hidden;
        border: 1px solid black;
    }
    .svg-content {
        display: inline-block;
        position: absolute;
        width:100%;
        height: 100% ;  
        top: 0;
        left: 0;
    }

    .node{
        fill: rgba(125, 125, 125, 1);
        r: 100;
        position:absolute;
    }

    .selected_node{
        fill: black;
        r: 4;
    }

    .unselected_node{

    }
    </style>

<script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="http://d3js.org/d3.v4.min.js" type="text/javascript"></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>
<script src="/libraries/gexf-parser.min.js"></script>
<!--<script src="https://1.jsconsole.com/js/remote.js?70fb9ec0-cab3-4775-9ab5-9daa813b0e48"></script>-->

<script type="text/javascript">

    const MAX_SCALE_FACTOR = 30.0;
    const MIN_SCALE_FACTOR = 0.1;
    const MAX_RADIUS = 20;
    const MIN_RADIUS = 1;
    const MAX_LINE_WIDTH = 10;
    const MIN_LINE_WIDTH = 0.1;
    const NODE_COLOR = "rgba(125, 125, 125, 1)";
    const EDGE_COLOR = "rgba(125, 125, 125, 0.8)";
    const SELECTED_NODE_COLOR = "rgba(0, 0, 0, 1)";
    const SELECTED_EDGE_COLOR = "rgba(0, 0, 0, 0.8)";
    const BACKGROUND_NODE_COLOR = "rgba(125, 125, 125, 0.2)";
    const BACKGROUND_EDGE_COLOR = "rgba(125, 125, 125, 0.2)";
    const BATCH_SIZE = 50;

    let nodes = {};
    let edges = {};
    window.nodes = {};
    window.edges = {};
    let adjacency_list = {};
    let drawing_timer;
    let MOVING = false;


    // define width/height as the svg container dimensions
    const width = document.getElementsByClassName('svg-container')[0].clientWidth;
    const height = document.getElementsByClassName('svg-container')[0].clientHeight;

    let svg = d3.select("div#graph").append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .classed("svg-content", true);

    let g = svg.append("g");

    svg.append('defs')
    .append('marker')
    .attrs({'id':'arrowhead',
        'viewBox':'-0 -5 10 10',
        'refX':23,
        'refY':0,
        'orient':'auto',
        'markerWidth':7,
        'markerHeight':7,
        'xoverflow':'visible'})
    .append('svg:path')
    .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
    .attr('fill', '#999')
    .style('stroke','none');


    // handle zoom events on the svg
    let zoom_handler = d3.zoom()

    .on("start", function(){
        return zoomBegin();
    })
    .on("end", function(){
        return zoomEnd(width, height, d3.event.transform);
    })
    .on("zoom", function(){
        return zoomed(g, width, height);
    });

    svg.call(zoom_handler);

    // When the background is clicked, clear the current selection
    d3.select("div#graph").on("click", function(){
        clear_selection(false);
    });


    // this function imports the data from a .gexf file
    // the advantage of gexf file is that we can use Gephi's algorithm to have a nice pre-defined layout
    // a callback function displays the data once it's loaded
    function import_data(path, display_callback){
        var graph = gexf.fetch(path);

        // import nodes data
        graph.nodes.forEach(function(n){
            nodes['nid_' + n.id] = {
                'x': n.viz.position.x,
                'y': n.viz.position.y,
                'title': n.attributes.subjectname,
                'id': 'nid_' + n.id
            };
        });

        // import edges data
        graph.edges.forEach(function(e){
            edges['eid_' + e.id] = {
                'source': 'nid_' + e.source,
                'target': 'nid_' + e.target,
                'x1': graph.nodes.filter(node => node.id == e.source)[0].viz.position.x,
                'y1': graph.nodes.filter(node => node.id == e.source)[0].viz.position.y,
                'x2': graph.nodes.filter(node => node.id == e.target)[0].viz.position.x,
                'y2': graph.nodes.filter(node => node.id == e.target)[0].viz.position.y,
                'id': 'eid_' + e.id,
                'type': e.label
            }
        });

        // fill the adjacency list
        Object.values(edges).forEach(function(e){
            if(!adjacency_list[e.source]) adjacency_list[e.source] = [];
            adjacency_list[(e.source)].push(e.id);
        });

        // display the data when loading is done
        display_callback();
    }

    function display_graph(){
        g.selectAll(".node")
            .data(Object.values(nodes)).enter()
            .append("circle")
            .attr("cx", function(d) {return d.x;})
            .attr("cy", function(d) {return d.y;})
            .attr("class", "node unselected_node")
            //.attr("radius", 100)
            .attr("id", d => d.id)
            .attr("title", d => d.subjectname)
            .on("click", function(d) {
                highlight_selection(d);
                d3.event.stopPropagation(); // only the node is clicked, not the background
            });
            //.append("title").text(function (d) { return d.attributes.subjectname;});


        // create an SVG line for each link in the JSON data
        g.selectAll(".link")
            .data(Object.values(edges)).enter()
            .append("line")
            .attr("x1", function(d) {return d.x1;})
            .attr("y1", function(d) {return d.y1;})
            .attr("x2", function(d) {return d.x2;})
            .attr("y2", function(d) {return d.y2;})
            .attr("id", function(d) {return d.id;})
            .attr("class", function(d) {
                console.log(d.label)
                return (d.type == 'baseline') ? 'link': 'link REQUIRE_IND';
            })
            .attr('marker-end','url(#arrowhead)');
    }


    // load and display
    import_data('/data/data4.gexf', function(){display_graph();});



    function get_node_size(scale_factor){
        //return (5/(Math.sqrt(scale_factor))).toFixed(1);
        return (10/scale_factor);
    }

    function get_line_width(scale_factor){
        return (1.0/((scale_factor))).toFixed(2);
    }

    // returns the coordinates after a transformation (zoom, pan)
    function get_new_coordinates(x, y, transf){
        let x1 = x * transf.k + transf.x,
        y1 = y * transf.k + transf.y;
        return [x1, y1];
    }

    // does this node appear on the screen with the current scale/translate values?
    function node_is_visible(node, width, height, transf){
        let x, y;
        //let radius = parseInt(g.select('#'+node.id).style('r'));
        // hardcode radius for performance reasons
        let radius = 100;
        [x, y] = get_new_coordinates(node.x, node.y, transf);
        return (x+radius) > 0 && (x-radius) < width && (y+radius) > 0 && (y-radius) < height;
    }

    // does this edge appear on the screen with the current scale/translate values?
    function edge_is_visible(edge, width, height, transf){
        let x1, x2, y1, y2;
        [x1, y1] = get_new_coordinates(edge.x1 ,edge.y1, transf);
        [x2, y2] = get_new_coordinates(edge.x2 ,edge.y2, transf);
        let new_edge = [x1, y1, x2, y2];
        let left_border = [0, 0, 0, height];
        let top_border = [0, 0, width, 0];
        let right_border = [width, 0, width, height];
        let bottom_border = [0, height, width, height];

        // both endpoints are inside the box
        if(x1 > 0 && x1 < width && y1 > 0 && y1 < height && x2 > 0 && x2 < width && y2 > 0 && y2 < height){
            return true;
        }
        // the edge intersects at least one of the borders
        if(line_intersects(new_edge, top_border) || line_intersects(new_edge, left_border) || line_intersects(new_edge, right_border) || line_intersects(new_edge, bottom_border)){
            return true;
        }
        return false;
    }

    // are the two segments intersecting at some point?
    function line_intersects(segment1, segment2) {
        [p0_x, p0_y, p1_x, p1_y] = segment1;
        [p2_x, p2_y, p3_x, p3_y] = segment2;
        var s1_x, s1_y, s2_x, s2_y;
        s1_x = p1_x - p0_x;
        s1_y = p1_y - p0_y;
        s2_x = p3_x - p2_x;
        s2_y = p3_y - p2_y;

        var s, t;
        s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
        t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);

        return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
    }

    // BFS search to highlight the given node and its neighbors
    // is_source: true if the node is the selected node (root node)
    // distance: highlight all nodes that are d hops away from the root, for all d <= distance
    // already_seen: the nodes that were already visited and highlightd by the algorithm (to avoid highlighting a node twice)
    function highlight_selection(node, is_source=true, distance=2, already_seen=[]){
        let node_id = node.id;

        if(is_source){
            clear_selection(true);
            already_seen.push(node_id);
        }
        highlight_node(node, distance);

        // also highlight neighbors (and the edge that links to each neighbor)
        if(distance > 0){
            if(!adjacency_list[node_id]) return;
            let adjacent_edges = adjacency_list[node_id].map(edge_id => get_edge_by_id(edge_id));
            adjacent_edges.forEach(edge => highlight_edge(edge, distance));
            let unvisited_nodes = adjacent_edges.map(edge => get_neighbor(node_id, edge)).filter(nid => !already_seen.includes(nid));
            unvisited_nodes.forEach(nid => already_seen.push(nid));
            unvisited_nodes.forEach(nid =>  highlight_selection(get_node_by_id(nid), false, distance-1, already_seen));
        }
    }

    // input: an edge and one of its endpoints
    //output: the other edge's endpoint
    function get_neighbor(node_id, edge){
        let neighbor;
        if(node_id == edge.source){
            neighbor = (edge.target);
        }
        else if(node_id == edge.target){
            neighbor = (edge.source);
        }
        return neighbor;
    }

    // highlights the given node with opacity proportional to the root distance
    function highlight_node(node, distance_to_leaf){
        const opacity = 0.4 + 0.3 * distance_to_leaf;
        d3.select('circle#'+node.id).style('fill', "rgba(0, 0, 0, " + opacity + ")");
    }

    // highlights an edge
    function highlight_edge(edge, distance_to_leaf){
        d3.select('#' + edge.id).style('stroke', SELECTED_EDGE_COLOR);
    }

    // returns the DOM node object given its node ID
    function get_node_by_id(id){
        return d3.select('#'+id).data()[0];
    }

    //input: edge id
    // output: the edge's data
    function get_edge_by_id(id){
        return d3.select('#'+id).data()[0];
    }

    // clears the highlighting and all node/edge selection
    function clear_selection(new_selection=false){
        if(new_selection){
            d3.selectAll('.node').style('fill', BACKGROUND_NODE_COLOR);
            d3.selectAll('.link').style('stroke', BACKGROUND_EDGE_COLOR);
        }
        else{
            d3.selectAll('.node').style('fill', NODE_COLOR);
            d3.selectAll('.link').style('stroke', EDGE_COLOR); 
        }
    }

    // This code is executed everytime the page is zoomed
    // It dinamically resizes the nodes and the edges
    // but only if they are visible to reduce computation time
    function zoomed(svg, width, height){
        d3.selectAll('.link').style('display', 'none');
        svg.attr("transform", d3.event.transform);
        const radius = get_node_size(d3.event.transform.k);
        d3.selectAll('.node').filter(node => node_is_visible(node, width, height, d3.event.transform)).style("r", radius); // update node size
    }

    // this function is called at the beginning of any zoom or drag event
    // it interrupts any ongoing drawing of edges
    function zoomBegin(){
        // Stop the timer if a zoom/drag occurs
        if(drawing_timer){
            console.log('stopped timer')
            drawing_timer.stop();
        }
    }

    // this function is called at the end of any zoom or drag event
    // it launches the redrawing of visible edges
    // the visible edges are drawn by batches of size BATCH_SIZE
    function zoomEnd(width, height, transform){
        const line_width = get_line_width(transform.k);
        let batch_number = 0;
        let visible_edges = d3.selectAll('.link').filter(edge => edge_is_visible(edge, width, height, transform)).data();
        // this timer calls its parameter function over and over again until it is stopped
        drawing_timer = d3.timer(function(){
            let batch = visible_edges.splice(0, Math.min(BATCH_SIZE, visible_edges.length));
            draw_edge_batch(batch, line_width);
            batch_number += 1;
            // stop the timer if all edges have been drawn
            if(visible_edges.length == 0){
                console.log('drawing complete');
                drawing_timer.stop();
            }
        }, 0);
    }

    // this function draws a single batch of edges
    // batch: an array of edge IDs to draw
    // line_width: the stroke width of the edges
    function draw_edge_batch(batch, line_width){
        g.selectAll('.link')
            .data(batch, function(e){return e.id;})
            .style('stroke-width', 0)
            .transition().duration(0)
            .style("stroke-width", line_width)
            .style('display', 'block');
    }


</script>

<script type="text/javascript">
    const t = $("table#results tbody");
    function clear_search(){
        $(".selected_node").attr("class", "node");
        t.empty();
    }

    function search() {
        var query=$("#search").find("input[name=search]").val();
        clear_search();
        if(query.length != 0){
            $.get("/search?q=" + encodeURIComponent(query),
                    function (data) {
                        if (!data || data.length == 0){
                            console.log("empty search");
                            return false;
                        }
                        // for each node returned by the query
                        data.forEach(function (course) {
                            // append a line in the list of selected courses with the course's title and code
                            $("<tr><td class='course'>" + course.title + "</td><td>" + course.code + "</td><td>" + "</td></tr>").appendTo(t);
                            var node = $('#' + course.id);
                            node.attr("class", "node selected_node");
                        });
                    }, "json");
        }
        return false;
        
    }

    $("#search").submit(search);
    //search();
</script>
</body>
</html>
