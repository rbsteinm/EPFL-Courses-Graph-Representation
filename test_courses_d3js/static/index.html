<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<link rel="stylesheet" href="http://neo4j-contrib.github.io/developer-resources/language-guides/assets/css/main.css">-->
    <title>EPFL courses - d3js/Neo4j</title>
</head>

<body>
<form role="search" class="navbar-form" id="search">
    <div class="form-group">
        <input type="text" placeholder="Search for courses" class="form-control" name="search">
    </div>
    <button class="btn btn-default" type="submit">Search</button>
</form>


<div id="graph" class = "svg-container"></div>

<table id="results" class="table table-striped table-hover">
    <thead>
    <tr>
        <th>Course</th>
        <th>Code</th>
    </tr>
    </thead>
    <tbody>
    </tbody>
</table>



<style type="text/css">
    .link {
        stroke: #999;
        stroke-opacity: .8;
        stroke-width: 1px;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        height: 85% ;
        vertical-align: top;
        overflow: hidden;
        border: 1px solid black;
    }
    .svg-content {
        display: inline-block;
        position: absolute;
        width:100%;
        height: 100% ;  
        top: 0;
        left: 0;
    }

    .node{
        fill: grey;
        r: 4;
        /*stroke: #222;
        stroke-width: 1.5px;*/
    }

    .selected_node{
        fill: black;
        r: 4;
    }

    .unselected_node{

    }
    </style>

<script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>

<script type="text/javascript">

    const MAX_SCALE_FACTOR = 30.0;
    const MIN_SCALE_FACTOR = 0.1;
    const MAX_RADIUS = 20;
    const MIN_RADIUS = 1;
    const MAX_LINE_WIDTH = 10;
    const MIN_LINE_WIDTH = 0.1;

    let neighbors_dict = {};

    function get_node_size(scale_factor){
        return (5/(Math.sqrt(scale_factor))).toFixed(1);
    }

    function get_line_width(scale_factor){
        return (1.0/((scale_factor))).toFixed(2);
    }

    // rescale the scaling factor to a value between 0 and 100
    /*function range_scaling_factor(factor, max_before, min_before, max_after, min_after){
        
        if(factor > max_before){
            factor = max_before;
        }
        else if(factor < min_before){
            factor = min_before;
        }
        percent = (factor - min_before) / (max_before - min_before);
        return Math.round(percent * (max_after - min_after) + min_after);
        //return  Math.round(100 * (factor - min_value) / (max_value - min_value));
    }*/

    function get_new_coordinates(x, y, matrix){
        let x1 = x * matrix.a + y * matrix.c + matrix.e,
        y1 = x * matrix.b + y * matrix.d + matrix.f;
        return [x1, y1];
    }

    function node_is_visible(node, width, height, matrix){
        //console.log(node.x);
        let x, y;
        [x, y] = get_new_coordinates(node.x, node.y, matrix)
        return x > 0 && x < width && y > 0 && y < height;
    }

    function edge_is_visible(edge, width, height, matrix){
        //console.log(edge.target.x);
        let x1, x2, y1, y2;
        [x1, y1] = get_new_coordinates(edge.source.x ,edge.source.y, matrix);
        [x2, y2] = get_new_coordinates(edge.target.x ,edge.target.y, matrix);
        //console.log(x1 + " " + x2 + " " + y1 + " " + y2);
        //console.log(edge.source.x + " " + edge.target.x);
        return (x1 > 0 && x1 < width && y1 > 0 && y1 < height) || (x2 > 0 && x2 < width && y2 > 0 && y2 < height);
    }

    function highlight_node(node, is_source=true){
        if(is_source){
            clear_selection();
        }
        console.log(node);
        node.classList.remove('unselected_node');
        node.classList.add('selected_node');
        node.style('opacity', 1);
        console.log(node);
        
        // also highlight neighbors
        if(is_source){
            highlight_neighbors(node.id);
            d3.selectAll('.unselected_node').style('opacity', 0.5);
        }
        /*
        console.log(neighbors);
        console.log(neighbors.length);
        for(let i = 0; i < neighbors.length; i++){
            console.log(get_node_by_id(neighbors[i]));
        }*/
        //console.log(get_node_by_id(neighbors[0]));

    }

    function get_node_by_id(id){
        return d3.select('[id="' + id + '"]')[0][0];
    }

    function highlight_neighbors(nodeId){
        $.get("/get_neighbors?q=" + encodeURIComponent(nodeId),
                function (data) {
                    if (!data || data.length == 0){
                        console.log("no neighbors");
                        return [];
                    }
                    data.forEach(function(node){
                        highlight_node(get_node_by_id(node.neigh), false);
                        //console.log(node.neigh);
                    });
                }, "json");
    }

    function clear_selection(){
        d3.selectAll('.selected_node').attr('class', 'node unselected_node');
        d3.selectAll('.node').style('opacity', 1);
    }

    function display_graph(){
        // define width/height as the svg container dimensions
        const width = document.getElementsByClassName('svg-container')[0].clientWidth;
        const height = document.getElementsByClassName('svg-container')[0].clientHeight;
        const force = d3.layout.force().charge(-200).linkDistance(30).size([width, height]);

        let radius;
        let line_width;
        let scale_factor;
        let matrix;

        const svg = d3.select("div#graph").append("svg")
            .attr("width", "100%").attr("height", "100%")
            .call(d3.behavior.zoom().on("zoom", function () {
                matrix = svg[0][0].getCTM();
                radius = get_node_size(d3.event.scale);
                line_width = get_line_width(d3.event.scale);
                
                svg.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");
                // when zooming, it updates the size of the nodes and edges
                d3.selectAll(".node").filter(node => node_is_visible(node, width, height, matrix)).style("r", radius);
                d3.selectAll(".link").filter(edge => edge_is_visible(edge, width, height, matrix)).style("stroke-width", line_width); // update edges size
            }))
            .classed("svg-content", true).append("g");

        
        d3.json("/graph", function(error, graph) {
    		if (error) return;

            force.nodes(graph.nodes).links(graph.links).start();

            var link = svg.selectAll(".link")
                    .data(graph.links).enter()
                    .append("line").attr("class", "link");

            // for each node in the JSON data, we create an svg circle and give it as attributes the node's id from neo4j
            var node = svg.selectAll(".node")
                    .data(graph.nodes).enter()
                    .append("circle")
                    .attr("class", "node unselected_node")
                    .attr("r", 10)
                    .attr("id", function(d) {return d.node_id})
                    .on("click", function() {
                        highlight_node(this);
                        //d3.event.stopPropagation();
                    });;
                    //.call(force.drag);

            /*node.each(function(d,i){
                    neighbors_dict[d.node_id] = [];
            });*/
            neighbors_dict = graph.neighbors_dict
            console.log(neighbors_dict[0]);

            // html title attribute
            node.append("title").text(function (d) { return d.title; })

            // force feed algo ticks
            force.on("tick", function() {
                node[0].x = width / 2;
                node[0].y = height / 2;
                link.attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });

                /*link.each(function(d,i){
                    neighbors_dict[d.source].push(d.target);
                    neighbors_dict[d.target].push(d.source);
                });*/

                node.attr("cx", function(d) { return d.x; })
                        .attr("cy", function(d) { return d.y; });
            });

            // Arrange nodes in background, and only display the graph when it's done
            force.start();
            for (let i = 1; i > 0; --i) force.tick();
            force.stop();
        });
    }
    display_graph();
</script>

<script type="text/javascript">
    const t = $("table#results tbody");
    function clear_search(){
        $(".selected_node").attr("class", "node");
        t.empty();
    }

    function search() {
        var query=$("#search").find("input[name=search]").val();
        clear_search();
        if(query.length != 0){
            $.get("/search?q=" + encodeURIComponent(query),
                    function (data) {
                        console.log(data);
                        if (!data || data.length == 0){
                            console.log("empty search");
                            return false;
                        }
                        // for each node returned by the query
                        data.forEach(function (course) {
                            // append a line in the list of selected courses with the course's title and code
                            $("<tr><td class='course'>" + course.title + "</td><td>" + course.code + "</td><td>" + "</td></tr>").appendTo(t);
                            var node = $('#' + course.id);
                            node.attr("class", "node selected_node");
                        });
                    }, "json");
        }
        return false;
        
    }

    $("#search").submit(search);
    //search();
</script>
</body>
</html>
