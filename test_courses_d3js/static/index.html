<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<link rel="stylesheet" href="http://neo4j-contrib.github.io/developer-resources/language-guides/assets/css/main.css">-->
    <title>EPFL courses - d3js/Neo4j</title>
</head>

<body>
<form role="search" class="navbar-form" id="search">
    <div class="form-group">
        <input type="text" placeholder="Search for courses" class="form-control" name="search">
    </div>
    <button class="btn btn-default" type="submit">Search</button>
</form>


<div id="graph" class = "svg-container"></div>

<table id="results" class="table table-striped table-hover">
    <thead>
    <tr>
        <th>Course</th>
        <th>Code</th>
    </tr>
    </thead>
    <tbody>
    </tbody>
</table>



<style type="text/css">
    .link {
        stroke: rgba(125, 125, 125, .8);
        /*stroke-opacity: .8;*/
        stroke-width: 1px;
    }

    .REQUIRE_IND{
        stroke-dasharray: 3;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        height: 85% ;
        vertical-align: top;
        overflow: hidden;
        border: 1px solid black;
    }
    .svg-content {
        display: inline-block;
        position: absolute;
        width:100%;
        height: 100% ;  
        top: 0;
        left: 0;
    }

    .node{
        fill: rgba(125, 125, 125, 1);
        r: 4;
        /*stroke: #222;
        stroke-width: 1.5px;*/
    }

    .selected_node{
        fill: black;
        r: 4;
    }

    .unselected_node{

    }
    </style>

<script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="http://d3js.org/d3.v4.min.js" type="text/javascript"></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>

<script type="text/javascript">

    const MAX_SCALE_FACTOR = 30.0;
    const MIN_SCALE_FACTOR = 0.1;
    const MAX_RADIUS = 20;
    const MIN_RADIUS = 1;
    const MAX_LINE_WIDTH = 10;
    const MIN_LINE_WIDTH = 0.1;
    const NODE_COLOR = "rgba(125, 125, 125, 1)";
    const EDGE_COLOR = "rgba(125, 125, 125, 0.8)";
    const SELECTED_NODE_COLOR = "rgba(0, 0, 0, 1)";
    const SELECTED_EDGE_COLOR = "rgba(0, 0, 0, 0.8)";
    const BACKGROUND_NODE_COLOR = "rgba(125, 125, 125, 0.2)";
    const BACKGROUND_EDGE_COLOR = "rgba(125, 125, 125, 0.2)";

    let nodes;
    let edges;
    let adjacency_list = {};
    let debug_transf;

    function get_node_size(scale_factor){
        return (5/(Math.sqrt(scale_factor))).toFixed(1);
    }

    function get_line_width(scale_factor){
        return (1.0/((scale_factor))).toFixed(2);
    }

    // returns the coordinates after a transformation (zoom, pan)
    function get_new_coordinates(x, y, transf){
        let x1 = x * transf.k + transf.x,
        y1 = y * transf.k + transf.y;
        return [x1, y1];
    }

    // does this node appear on the screen with the current scale/translate values?
    function node_is_visible(node, width, height, transf){
        let x, y;
        [x, y] = get_new_coordinates(node.x, node.y, transf);
        return x > 0 && x < width && y > 0 && y < height;
    }

    // does this edge appear on the screen with the current scale/translate values?
    function edge_is_visible(edge, width, height, transf){
        let x1, x2, y1, y2;
        [x1, y1] = get_new_coordinates(edge.source.x ,edge.source.y, transf);
        [x2, y2] = get_new_coordinates(edge.target.x ,edge.target.y, transf);
        return (x1 > 0 && x1 < width && y1 > 0 && y1 < height) || (x2 > 0 && x2 < width && y2 > 0 && y2 < height);
    }

    // BFS search to highlight the given node and its neighbors
    // is_source: true if the node is the selected node (root node)
    // distance: highlight all nodes that are d hops away from the root, for all d <= distance
    // already_seen: the nodes that were already visited and highlightd by the algorithm (to avoid highlighting a node twice)
    function highlight_selection(node, is_source=true, distance=2, already_seen=[]){
        if(is_source){
            clear_selection(true);
            already_seen.push(Number(node.id));
        }
        highlight_node(node, distance);

        // also highlight neighbors (and the edge that links to each neighbor)
        if(distance > 0){
            let adjacent_edges = adjacency_list[node.id].map(edge_id => get_edge_by_id(edge_id));
            adjacent_edges.forEach(edge => highlight_edge(edge, distance));
            let unvisited_nodes = adjacent_edges.map(edge => get_neighbor(node.id, edge)).filter(node_id => !already_seen.includes(node_id));
            unvisited_nodes.forEach(node_id => already_seen.push(node_id));
            unvisited_nodes.forEach(node_id =>  highlight_selection(get_node_by_id(node_id), false, distance-1, already_seen));
        }
    }

    // input: an edge and one of its endpoints
    //output: the other edge's endpoint
    function get_neighbor(node_id, edge){
        let neighbor;
        if(node_id == edge.source.node_id){
            neighbor = (edge.target.node_id);
        }
        else if(node_id == edge.target.node_id){
            neighbor = (edge.source.node_id);
        }
        return Number(neighbor);
    }

    // highlights the given node with opacity proportional to the root distance
    function highlight_node(node, distance_to_leaf){
        const opacity = 0.4 + 0.3 * distance_to_leaf;
        node.style['fill'] = "rgba(0, 0, 0, " + opacity + ")";
        //node.style['fill'] = SELECTED_NODE_COLOR;
    }

    // highlights an edge
    function highlight_edge(edge, distance_to_leaf){
        d3.select('#id_' + edge.edge_id).style('stroke', SELECTED_EDGE_COLOR);
    }

    // returns the DOM node object given its node ID
    function get_node_by_id(id){
        return d3.select('[id="' + id + '"]').node();
    }

    //input: edge id
    // output: the edge's data
    function get_edge_by_id(id){
        return d3.select('#id_'+id).data()[0];
    }

    // clears the highlighting and all node/edge selection
    function clear_selection(new_selection=false){
        if(new_selection){
            nodes.style('fill', BACKGROUND_NODE_COLOR);
            edges.style('stroke', BACKGROUND_EDGE_COLOR);
        }
        else{
            nodes.style('fill', NODE_COLOR);
            edges.style('stroke', EDGE_COLOR); 
        }
    }

    // This code is executed everytime the page is zoomed
    // It dinamically resizes the nodes and the edges
    // but only if they are visible to reduce computation time
    function zoomed(svg, width, height){
        debug_transf = d3.event.transform;
        svg.attr("transform", d3.event.transform);
        const radius = get_node_size(d3.event.transform.k);
        const line_width = get_line_width(d3.event.transform.k);
        
        nodes.filter(node => node_is_visible(node, width, height, d3.event.transform)).style("r", radius); // update node size
        edges.filter(edge => edge_is_visible(edge, width, height, d3.event.transform)).style("stroke-width", line_width); // update edges size
    }

    function display_graph(){
        // define width/height as the svg container dimensions
        const width = document.getElementsByClassName('svg-container')[0].clientWidth;
        const height = document.getElementsByClassName('svg-container')[0].clientHeight;
        let radius;
        let line_width;
        let matrix;

        let svg = d3.select("div#graph").append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .classed("svg-content", true);

        let g = svg.append("g");

        svg.append('defs')
        .append('marker')
        .attrs({'id':'arrowhead',
            'viewBox':'-0 -5 10 10',
            'refX':13,
            'refY':0,
            'orient':'auto',
            'markerWidth':13,
            'markerHeight':13,
            'xoverflow':'visible'})
        .append('svg:path')
        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
        .attr('fill', '#999')
        .style('stroke','none');



        let zoom_handler = d3.zoom().on("zoom", function(){
            zoomed(g, width, height);
        });
        zoom_handler(svg);

        // When the background is clicked, clear the current selection
        d3.select("div#graph").on("click", function(){
            clear_selection(false);
        });

        
        d3.json("/graph", function(error, graph) {
            if (error) return;

            let forceSimulation = d3.forceSimulation();
            forceSimulation.nodes(graph.nodes);
            let link_force = d3.forceLink(graph.links).distance(100).strength(1).iterations(10);//.id(function(d){return d.source})
            let charge_force = d3.forceManyBody().strength(-20);
            let center_force = d3.forceCenter(width / 2, height / 2);

            forceSimulation
                .force("charge_force", charge_force)
                .force("center_force", center_force)
                .force("links",link_force)
                .force("x", d3.forceX())
                .force("y", d3.forceY());

            for (let i = 10; i > 0; --i){
                forceSimulation.tick();
            }
            forceSimulation.stop();


            // create an SVG line for each link in the JSON data
            edges = g.selectAll(".link")
                    .data(graph.links).enter()
                    .append("line")
                    .attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; })
                    .attr("id", function(d) {return 'id_' + d.edge_id;})
                    .attr("class", function(d) {return "link " + d.edge_type})
                    .attr('marker-end','url(#arrowhead)');

            // for each node in the JSON data, we create an svg circle and give it as attributes the node's id from neo4j
            nodes = g.selectAll(".node")
                    .data(graph.nodes).enter()
                    .append("circle")
                    .attr("cx", function(d) { return d.x; })
                    .attr("cy", function(d) { return d.y; })
                    .attr("class", "node unselected_node")
                    .attr("r", 10)
                    .attr("id", d => d.node_id)
                    .on("click", function(d) {
                        highlight_selection(this);
                        d3.event.stopPropagation(); // only the node is clicked, not the background
                    });
                    //.call(force.drag);
            
            // fill in adjacency list
            adjacency_list = graph.adjacency_lists['ALL_EDGES'];

            // html title attribute
            nodes.append("title").text(function (d) { return d.title; })

            // force feed algo ticks
            forceSimulation.on("tick", function() {
                edges.attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });
                nodes.attr("cx", function(d) { return d.x; })
                        .attr("cy", function(d) { return d.y; });
            });
        });
    }
    display_graph();
</script>

<script type="text/javascript">
    const t = $("table#results tbody");
    function clear_search(){
        $(".selected_node").attr("class", "node");
        t.empty();
    }

    function search() {
        var query=$("#search").find("input[name=search]").val();
        clear_search();
        if(query.length != 0){
            $.get("/search?q=" + encodeURIComponent(query),
                    function (data) {
                        if (!data || data.length == 0){
                            console.log("empty search");
                            return false;
                        }
                        // for each node returned by the query
                        data.forEach(function (course) {
                            // append a line in the list of selected courses with the course's title and code
                            $("<tr><td class='course'>" + course.title + "</td><td>" + course.code + "</td><td>" + "</td></tr>").appendTo(t);
                            var node = $('#' + course.id);
                            node.attr("class", "node selected_node");
                        });
                    }, "json");
        }
        return false;
        
    }

    $("#search").submit(search);
    //search();
</script>
</body>
</html>
